Playbooks
~~~~~~~~~~~

Playbooks Ansible предлагают воспроизводимую, многократно используемую, простую систему управления конфигурацией и развертывания на нескольких компьютерах, которая хорошо подходит для развертывания сложных приложений. 
Это файл, в котором описываются действия, которые нужно выполнить на какой-то группе хостов.
Если необходимо выполнить задачу с помощью Ansible более одного раза, создается playbook и помещается в систему управления версиями. 
Затем можно использовать плейбук для запуска новой конфигурации или подтверждения конфигурации удаленных систем. 

Для работы Playbooks необходимо:

* объявить конфигурации;
* организовать этапы любого процесса, упорядоченного вручную, на нескольких наборах машин в определенном порядке;
* запустить задачи синхронно или асинхронно

Синтаксис playbook:
"""""""""""""""""""""

Playbooks представлены в формате YAML с минимальным синтаксисом. 

Playbook состоит из одной или нескольких "play" в упорядоченном списке. 
Каждая play выполняет часть общей цели playbook, выполняя одну или несколько задач. Каждая задача вызывает модуль Ansible.

Выполнение Playbook
"""""""""""""""""""""""

Playbook выполняется по порядку сверху вниз. 
В каждом блоке задания также выполняются по порядку сверху вниз. 
Playbooks с несколькими "plays" могут организовывать развертывание на нескольких компьютерах, запуская один з игру на ваших веб-серверах, 
затем другую игру на серверах баз данных, затем третью игру в вашей сетевой инфраструктуре и так далее. 

Как минимум, каждый play определяет две вещи:

* управляемые узлы, для которых требуется выполнить работу, используя шаблон;
* как минимум одна задача для выполнения.

Пример:
''''''''
::

	- name: "First step"
	hosts: localhost
	tasks:
	- taskA
	- taskB

	- name: "Second step"
	hosts: all
	tasks:
	- taskC
	- taskD


Выполнение задачи (task)
"""""""""""""""""""""""

Как правило **task** - это всего-лишь модуль Ansible. То есть при вызове какой-либо **task**, на самом деле вызывается модуль Ansible с его параметрами. 
Поэтому богатство "языка" Ansible зависит от количества его модулей.
Записать task можно в двух видах: кратком, и полном. Вот пример команды установки имени хоста (hostname):

::

	- name: Set a hostname
  	  ansible.builtin.hostname:
    		name: ansible


По умолчанию Ansible выполняет каждую задачу по порядку, по одной за раз, на всех машинах, соответствующих шаблону хоста. 
Каждая задача выполняет модуль с определенными аргументами. Когда задача выполнена на всех целевых машинах, Ansible переходит к следующей задаче. 
В каждой play Ansible применяет одни и те же директивы задач ко всем хостам. 
Если на хосте происходит сбой задачи, Ansible выводит этот хост из ротации для остальной части сценария.


В данном скрипте установлено имя хоста **ansible** для хоста localhost.


**Запуск playbook**

Cохранить получившийся текст в файл "first.yml" и запустить его следующим образом:

ansible-playbook ./first.yml

Порядок выполнения задач и сценариев
""""""""""""""""""""""""""""""""""""

Сценарии (play) и задачи (task) выполняются последовательно, в том порядке, в котором они описаны в playbook.

Если в сценарии, например, две задачи, то сначала первая задача должна быть выполнена для всех устройств, которые указаны в параметре hosts. 
Только после того, как первая задача была выполнена для всех хостов, начинается выполнение второй задачи.

Если в ходе выполнения playbook возникла ошибка в задаче на каком-то устройстве, это устройство исключается, и другие задачи на нём выполняться не будут.


Желаемое состояние и "идемпотентность"
""""""""""""""""""""""""""""""""""""""""""

Большинство модулей Ansible проверяют, достигнуто ли уже желаемое конечное состояние, и выходят без выполнения каких-либо действий, если это состояние достигнуто, чтобы повторение задачи не изменило конечное состояние. 
Модули, которые ведут себя таким образом, часто называют "идемпотентными". Независимо от того, запускаете ли вы playbook один раз или несколько раз, результат должен быть одинаковым. 
Модули можно выполнять сколько угодно раз, но при этом модуль будет выполнять изменения, только если система не находится в желаемом состоянии.
Однако не все ведут себя таким образом. Из этого правила есть исключения. Например, модуль raw всегда вносит изменения.

Если, например, в задаче указано, что на сервер Linux надо установить пакет httpd, то он будет установлен только в том случае, если его нет. 
То есть, действие не будет повторяться снова и снова при каждом запуске, а лишь тогда, когда пакета нет.

Необходимо тестировать свои playbook в изолированной среде, прежде чем запускать их несколько раз в рабочей среде.

Желаемое состояние и "идемпотентность"
""""""""""""""""""""""""""""""""""""""""""

Большинство модулей Ansible проверяют, достигнуто ли уже желаемое конечное состояние, и выходят без выполнения каких-либо действий, если это состояние достигнуто, чтобы повторение задачи не изменило конечное состояние. 
Модули, которые ведут себя таким образом, часто называют "идемпотентными". Независимо от того, запускаете ли вы playbook один раз или несколько раз, результат должен быть одинаковым. 
Однако не все ведут себя таким образом. Необходимо тестировать свои playbook в изолированной среде, прежде чем запускать их несколько раз в рабочей среде.



