Контейнеризация и Docker
###########################

**Контейнеризация** (виртуализация на уровне операционной системы, контейнерная виртуализация, зонная виртуализация) — метод виртуализации, 
при котором ядро операционной системы поддерживает несколько изолированных экземпляров пространства пользователя вместо одного. 
Эти экземпляры (обычно называемые контейнерами или зонами) с точки зрения выполняемых в них процессов идентичны отдельному экземпляру операционной системы.  
Ядро обеспечивает полную изолированность контейнеров, поэтому программы из разных контейнеров не могут воздействовать друг на друга.

В отличие от аппаратной виртуализации, при которой эмулируется аппаратное окружение и может быть запущен широкий спектр гостевых операционных систем, 
в контейнере может быть запущен экземпляр операционной системы только с тем же ядром, что и у хостовой операционной системы (все контейнеры узла используют общее ядро). 
При этом при контейнеризации отсутствуют дополнительные ресурсные накладные расходы на эмуляцию виртуального оборудования и запуск полноценного экземпляра операционной системы, 
характерные при аппаратной виртуализации.

Существуют реализации, ориентированные на создание практически полноценных экземпляров операционных систем (Solaris Containers, контейнеры Virtuozzo, OpenVZ), 
так и варианты, фокусирующиеся на изоляции отдельных сервисов с минимальным операционным окружением (jail, Docker).

**Docker** — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. 
Позволяет "упаковать" приложение со всем его окружением и зависимостями в контейнер, который может быть развёрнут на любой Linux-системе с поддержкой контрольных групп в ядре, 
а также предоставляет набор команд для управления этими контейнерами.

Разрабатывается и поддерживается одноимённой компанией-стартапом, распространяется в двух редакциях — общественной (Community Edition) по лицензии Apache 2.0 и 
для организаций (Enterprise Edition) по проприетарной лицензии. Написан на языке Go.

Подробнее: https://ru.wikipedia.org/wiki/Docker

Контейнерная платформа Docker всегда работает поверх операционной системы хоста. Контейнеры содержат двоичные файлы, библиотеки и само приложение. 
Контейнеры не содержат гостевой операционной системы, которая обеспечивает легкий вес контейнеров.
Напротив, виртуальные машины работают на гипервизоре (отвечает за запуск виртуальных машин) и включают собственную гостевую операционную систему. 
Это значительно увеличивает размер виртуальных машин, усложняет настройку виртуальных машин и требует больше ресурсов для запуска каждой виртуальной машины.

.. figure:: img/docker_01.png
       :scale: 100 %
       :align: center
       :alt: asda


Docker используется с целью получения работоспособных приложений, совместимых со всеми популярными операционными системами. 
Конфигурация приложения собирается автоматически и код выполняется всегда, даже при отсутствии необходимого окружения и установленного программного обеспечения.


.. rubric:: Image (Изображение)

**Image** Docker содержит все необходимое для запуска приложения в качестве контейнера. Это включает в себя:

* библиотеки кода;
* среды выполнения переменные;
* среды файлы конфигурации.
  
Затем образ может быть развернут в любой среде Docker и выполнен в виде контейнера. 
Docker имеет различные образы ПО: ubuntu, php (который наследуется от оригинального образа Ubuntu), nodejs, и т.д.

.. note:: Image - это шаблон 

.. rubric:: Контейнер

**Контейнер Docker** - это экземпляр образа во время выполнения. 

Из одного изображения вы можете создать несколько контейнеров на нескольких платформах Docker. 
Контейнер выполняется как отдельный процесс на главной машине. 
Поскольку контейнер запускается без необходимости загрузки гостевой операционной системы, он имеет небольшой вес и ограничивает ресурсы (например, память), 
необходимые для его запуска. Контейнер является полностью независимым и изолированным от основной операционной системы, аналогично виртуальной операционной системе. 
Можно вносить любые изменения внутри , и никакие из этих изменений не повлияют на основную операционную систему.


Установка Docker
*******************

Docker доступен для любой из операционных систем: Windows, Linux, Maс.

**Alt:**

::

        apt-get install docker-engine

        docker --help


.. figure:: img/docker_02.png
       :scale: 100 %
       :align: center
       :alt: asda

Установка Docker в качестве службы
====================================

::

        systemctl start docker
        systemctl enable docker
        systemctl status docker

Версия docker
==============

::

        docker version

Работа с image
******************

**Выбор Image**

Теперь, когда Docker запущен и запущен, необходимо выбрать **image**, чтобы запустить контейнер docker. 
Чтобы выбора image из списка уже существующих изображений Docker, можно перейти на hub.docker.com:


Скачивание образа
====================

::

        docker pull <IMAGE_NAME>, где <IMAGE_NAME> - имя скачиваемого образа

**Например:**

::

        docker pull ubuntu:20.04

Эта команда сообщает Докеру о том, что нужно скачать образ Ubuntu 20.04 с Dockerhub.com - основной репозиторий Docker-образов

Просмотр образа
===================

::

        docker images

.. figure:: img/docker_03.png
       :scale: 100 %
       :align: center
       :alt: asda

Удаление образа
====================

::

        docker rmi <IMAGE_ID>

.. figure:: img/docker_06.png
       :scale: 100 %
       :align: center
       :alt: asda


Операции с контейнерами
***************************

Запуск контейнера
==================

::

        docker run <image> <опциональная команды, которая выполнится внутри контейнера>

        docker run ubuntu:20.04 echo 'Ubuntu in docker'

Список запущенных контейнеров
================================

Активных:

::

        docker ps

Всех:

::
  
        docker ps -a


После выполнения нужных операций внутри контейнера, Docker-контейнер завершает работу.
Каждый раз, команда **docker run**, создает новый контейнер, на каждую из выполняемых команд.

Выполнение неограниченного количества команда внутри контейнера
================================================================

::

        docker run -it ubuntu:20.04 /bin/bash

Опция **-it** - преход в конвейер

**/bin/bash** выполнение команды при входе в контейнер (даёт доступ к выполнению команд в терминале внутри контейнера Ubuntu.)

::

        docker ps -a   # просмотрим список активных контейнеров 
        docker stop aa1463167766   # остановить активный контейнер
        docker rm aa1463167766     # удалить контейнер
        docker rm bb597feb7fbe     # удалить второй контейнер
        docker ps a   # просмотрим список активных контейнеров 
        docker rm -a   # удалить все контейнеры 

Создание приложения и образа для Docker
*****************************************

Dockerfile
===========

**Dockerfile** - это обычный конфигурационный файл, описывающий пошаговое создание среды приложения. 
В этом файле подробно описывается, какие команды будут выполнены, какие образы задействованы, и какие настройки будут применены. 
А движок Docker-а при запуске уже распарсит этот файл (именуемый как Dockerfile), и создаст из него соответствующий образ (Image), который был описан.

Быстрый пример с Python
------------------------

::

	vim index.py

.. code:: python

	print('Hello from Python in DOCKER!')

::

	vim Dockerfile

	FROM python
	WORKDIR /app
	COPY . /app
	CMD ["python", "index.py"]


* FROM - использовать готовый образ 
* WORKDIR - задать рабочую директорию в контейнере 
* COPY - Копирует файл с основной системы в контейнер (копируем все файлы внутрь контейнера)
* RUN - Выполнение shell-команды из терминала контейнера
* CMD - Выполняет эту команду каждый раз, при новом запуске контейнера


Для создания образа из Dockerfile нужно выполнить:

::

	docker build <DOCKERFILE_PATH> --tag <IMAGE_NAME>

	<DOCKERFILE_PATH> - путь к файлу Dockerfile (. - текущая директория),

	<IMAGE_NAME> - имя, под которым образ будет создан

При том, что имя файла Dockerfile при указывании пути упускается, нужно указывать только директорию, в которой этот файл находится 
(а . означает, что файл находится в той директории, из которой была запущена консоль)

::
        
	docker build . --tag hello_python

.. figure:: img/docker_04.png
       :scale: 100 %
       :align: center
       :alt: asda

::
        
	docker image ls

	docker run hello_python

Список всех команд:

https://docs.docker.com/engine/reference/builder/#from

Монтирование локальной директории в Docker-контейнер
*****************************************************

Монтирование директории в Docker контейнер - это предоставление доступа контейнеру на чтение содержимого вашей папки из основной операционной системы. 
Помимо чтения из этой папки, так же, контейнер может её изменять, и такая связь является двусторонней: 
при изменении файлов в основной ОС изменения будут видны в контейнере, и наоборот.

**Синтаксис:**

::

	docker run -v <DIRECTORY>:<CONTAINER_DIRECTORY>:z ...,

* **DIRECTORY** - это путь к папке, которую нужно смонтировать
* **CONTAINER_DIRECTORY** - путь внутри контейнера.
* **:z** - указывает, что содержимое привязки монтирования является общим для нескольких контейнеров.

.. note:: путь к монтируемой папке должен быть прописан полностью: C:\projects\docker-example, или на **nix**-системах можно воспользоваться конструкцией $(pwd) 

Пример:

Команда:

::

	docker run -it -v ~/image01:/app hello_python /bin/bash

Создает контейнер и монтирует каталог **~/image01** в каталог **/app** контейнера

.. figure:: img/docker_05.png
       :scale: 100 %
       :align: center
       :alt: asda

Это удобная особенность, которая позволяет выполнять редактирование кода в редакторе на основной ОС, а изменения будут сразу же применяться внутри контейнера.

Порты контейнеров
====================

Docker позволяет получить доступ к какому-то из портов контейнера, пробросив его наружу (в основную операционную систему). 
По умолчанию, нет возможности получить доступ к каким-либо из портов контейнера. Однако, в Dockerfile опция EXPOSE позволяет объявить, 
к какому из портов можно обратиться из основной ОС.

::

	docker run -p <HOST_PORT>:<CONTAINER_PORT>

Пример: 

Создать образ для работы apache с установленным php и запустить в контейнере. 
Обращение к apache из сети опеспечить через обращение к хостовой машине на порту 8080

1. Создать и перейти в каталог html:

::

	mkdir html
	cd html

Создать индексный файл index.php:
        
::
        
	<?php
			echo 'Hello from DOCKER-apache. We have PHP version = ' . phpversion() . PHP_EOL;
	?>
        


2.  Создать Dockerfile:

::

	FROM php:7.2-apache
	WORKDIR /var/www/html
	COPY . /var/www/html
	#Прокинуть системный порт (Expose)
	EXPOSE 80

EXPOSE в Dockerfile разрешает подключение к 80 порту контейнера.

3. Собрать обрз

::

	docker build . --tag own_php_apache

4. Запустить контейнер

::

	docker run own_php_apache -p 80:80


Классы задач для Docker:
================================

* Упрощение процесса разворачивания/сопровождения проектов.

Docker позволяет разбить проект на небольшие независимые, удобные в сопровождении компоненты, работать с которыми гораздо комфортнее, 
чем с реальными сущностями вроде Apache 2.4.12, установленного на хосте 1.2.3.4, работающем под управлением CentOS 6.

* Continous development и zero-downtime deployment. 

Каждый образ Docker — вещь в себе, включающая сервис (или набор сервисов), окружение для его запуска и необходимые настройки. 
Поэтому контейнеры можно передавать между членами команды в ходе цикла «разработка -> тестирование -> внедрение» и быстро внедрять изменения, 
просто переключая настройки на новые контейнеры.

* IaaS/PaaS. Благодаря легковесности контейнеров Docker можно использовать в качестве движка виртуализации в IaaS, 
а благодаря простоте миграции Docker становится идеальным решением для запуска сервисов в PaaS.

* Запуск небезопасного кода. Docker позволяет запустить любой, в том числе графический софт внутри изолированного контейнера с помощью одной простой команды. 
Поэтому он идеально подходит для запуска разного рода недоверенного или просто небезопасного кода.